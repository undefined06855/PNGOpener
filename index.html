<!DOCTYPE html>

<html dir="ltr" lang="en">
    <head>
        <title>png opener (shitty)</title>

        <style>
            * {
                font-family: "Courier New", Courier, monospace;
            }

            #wrapper {
                display: flex;

                position: fixed;
                top: 0;
                left: 0;
                bottom: 0;
                right: 0;

                flex-wrap: wrap;
                flex-direction: row;
            }

            fieldset {
                overflow: scroll;

                flex-basis: calc(50% - 40px);
                background-color: #fff;
                width: 50%;
                height: 50%;

                min-width: 0px;
            }

            #out {
                min-width: 100%;
            }

            input, .btn {
                font-size: 25px;
            }

            .btn {
                width: 150px;
                height: 150px;
            }
        </style>
    </head>

    <body>
        <div id="wrapper">
            <fieldset>
                <legend>Buttons:</legend>
                <input id="file" type="file" accept="image/png" /><hr/>
                <button class="btn" onclick="parse()">Parse PNG</button>
                <button class="btn" onclick="copylogs()">Copy logs</button>
            </fieldset>

    
            <fieldset id="chunks">
                <legend>Chunks:</legend>
            </fieldset>
    
            <fieldset id="out">
                <legend>Log:
                    <button onclick="document.getElementById('out').querySelectorAll('div').forEach(e => e.remove()); logstr = ''">CLEAR</button>
                    <button onclick="copylogs()"><b>COPY</b></button>
                </legend>
            </fieldset>
        </div>

        <!--canvas id="canvas">your browser does not support canvas :( get a better browser</canvas-->

        <script>

            function buf2hex(buffer)
            { // buffer is an ArrayBuffer
            return [...new Uint8Array(buffer)]
                .map(x => x.toString(16).padStart(2, '0'))
                .join('');
            }

            function log(str, bg="#fff")
            {
                logstr += str + ""
                console.log(str)
                line = document.createElement("div")
                line.innerText = str
                // format warnings / errors
                line.style.backgroundColor = bg
                document.getElementById("out").appendChild(line)
            }

            function copylogs()
            { // def not copied from stackoverflow :)))))
                const mySmartTextarea = document.createElement("textarea");
                mySmartTextarea.innerHTML = logstr;
                const parentElement = document.body.appendChild(mySmartTextarea);
                mySmartTextarea.select();
                document.execCommand("copy");
                document.body.removeChild(mySmartTextarea);
            }

            function addchunks(data)
            {
                chunk = document.createElement("fieldset")
                title = document.createElement("legend")

                document.getElementById("chunks").appendChild(chunk)

                title.innerText = data.name
                
                descDiv = document.createElement("div")
                descDiv.innerText = data.desc

                chunk.appendChild(title)

                chunk.appendChild(descDiv)
            }

            logstr = ""

            file = document.querySelector("#file")

            filetype = "N/A"
            isvalid = false

            coltypes = [
                "greyscale",
                "ERROR - OUT OF RANGE (1)",
                "truecolor",
                "indexed-color",
                "greyscale+alpha",
                "ERROR - OUT OF RANGE (5)",
                "truecolor+alpha"
            ]

            validbitdepths = [
                [1, 2, 4, 8, 16],
                [-1],
                [8, 16],
                [1, 2, 4, 8],
                [8, 16],
                [-1],
                [8, 16]
            ]
            
            descs = {
                "IHDR": "Image header chunk.",
                "PLTE": "Palette entries.",
                "IDAT": "Actual image data.",
                "IEND": "End of the image file.",
                "tRNS": "Indicates that the image uses \"simple\" transparency.",
                "gAMA": "The gamma value of the image.",
                "cHRM": "Specifies chromaticities of the red, green, and blue primaries.",
                "sRGB": "Indicates that the image conforms to the sRGB color space.",
                "iCCP": "Indicates that the image conforms to the embedded ICC profile.",
                "iTXt": "International text metadata about the image.",
                "tEXt": "Text metadata about the image.",
                "zTXt": "Compressed text metadata about the image.",
                "bKGD": "Represents default background color.",
                "pHYs": "Specifies intended pixel size or aspect ratio.",
                "sBIT": "Stores the original number of significant bits.",
                "sPLT": "Suggests a reduced color palette to be used.",
                "hIST": "Specifies the approximate usage frequency of each color in the palette.",
                "tIME": "Specifies the last time the image was modified."
            }

            function bitdepthisvalid(coltype, bitdepth)
            {
                return validbitdepths[coltype].includes(bitdepth)
            }

            function parse()
            {
                var reader = new FileReader();
                
                reader.onload = function() {
                    var arrayBuffer = this.result
                    imageraw = new Uint8Array(arrayBuffer)
                    imagehex = buf2hex(arrayBuffer)

                    filetype =
                    String.fromCharCode(imageraw[1]) +
                    String.fromCharCode(imageraw[2]) +
                    String.fromCharCode(imageraw[3])

                    chunkType = ""
                    chunkLen = 0
                    offset = 8
                    maxChunks = 10 // increase if chunks are being cut off
                    curChunk = 0

                    validchunks = true

                    IDAT = []
                    IHDR = ["N/A"]

                    chunks = []


                    // log chunks
                    log("Chunks:", "#00f")
                    while (chunkType != "IEND" && maxChunks > curChunk)
                    {
                        curChunk++
                        chunkLen = 
                            imageraw[offset + 0] +
                            imageraw[offset + 1] +
                            imageraw[offset + 2] +
                            imageraw[offset + 3]
                        
                        chunkType =
                            String.fromCharCode(imageraw[offset + 4]) +
                            String.fromCharCode(imageraw[offset + 5]) +
                            String.fromCharCode(imageraw[offset + 6]) +
                            String.fromCharCode(imageraw[offset + 7])

                        chunkLenStr = chunkLen.toString().padStart(3, "0") // pads length

                        if (descs[chunkType] == undefined) log(`(${chunkLenStr} byte(s)) ${chunkType} (INVALID CHUNK)`, "#f00")
                        else log(`(${chunkLenStr} byte(s)) ${chunkType}`)


                        data = imageraw.slice(offset + 8, offset + 8 + chunkLen + 1)
                        //                             ^           ^
                        //        counteract the length and type metadata in the chunk

                        if (chunkType == "IDAT") IDAT += data // may be multiple idat chunks
                        else if (/^[a-z]+$/i.test(chunkType)) eval("var " + chunkType + " = data") // make var for each chunk
                        else validchunks = false

                        chunks.push({
                            "type": chunkType,
                            "metadata": {
                                "len": chunkLen,
                                "chunkOffset": offset
                            },
                            "data": data
                        })

                        chunkDesc = descs[chunkType]

                        if (chunkDesc == undefined) chunkDesc = "N/A"

                        addchunks({
                            "name": chunkType,
                            "desc": chunkDesc,
                        })

                        // vvvv offset should be where the new chunk is
                        offset += chunkLen + 4 + 4 + 4
                        //                  len typ crc
                    }

                    IDAT = Uint8Array.from(IDAT)

                    /*
                    firstChunkLen = 
                    imageraw[8] +
                    imageraw[9] +
                    imageraw[10] +
                    imageraw[11]

                    firstChunkType =
                    String.fromCharCode(imageraw[12]) +
                    String.fromCharCode(imageraw[13]) +
                    String.fromCharCode(imageraw[14]) +
                    String.fromCharCode(imageraw[15])
                    */

                    // parse IHDR:

                    width =
                    IHDR[0] +
                    IHDR[1] +
                    IHDR[2] +
                    IHDR[3]

                    height =
                    IHDR[4] +
                    IHDR[5] +
                    IHDR[6] +
                    IHDR[7]

                    bitdepth = IHDR[8]


                    coltype = coltypes[IHDR[9]]

                    isvalid = // this should be the same in every png file
                    imageraw[0] == 137   &&
                    imageraw[1] == 80    &&
                    imageraw[2] == 78    &&
                    imageraw[3] == 71    &&
                    imageraw[4] == 13    &&
                    imageraw[5] == 10    &&
                    imageraw[6] == 26    &&
                    imageraw[7] == 10    &&
                    coltype != undefined &&
                    height > 0           &&
                    width > 0            &&
                    bitdepthisvalid(IHDR[9], IHDR[8])

                    log(`Image info:`, "#0f0")
                    log(`Width: ${width}`)
                    log(`Height: ${height}`)
                    log(`Type: ${filetype}`)
                    log(`Bitdepth: ${bitdepth}`)
                    if (coltype != undefined) log(`Colortype: ${coltype} (${IHDR[9]})`)
                    else                      log(`Colortype: ERR (${IHDR[9]})`)
                    log(`Valid?: ${isvalid}`)
                    log(`Valid chunks?: ${validchunks}`)



                    //log(imageraw, "#00f")

                    log("IDAT:", "#f0f")
                    log(IDAT, "#f0f")

                    log("IHDR:", "#f0f")
                    log(IHDR, "#f0f")
                    //binaryString = String.fromCharCode.apply(null, image);
                }

                reader.readAsArrayBuffer(file.files[0]);
            }
        </script>
    </body>
</html>
